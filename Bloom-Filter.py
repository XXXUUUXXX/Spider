参考博客：http://blog.csdn.net/bone_ace/article/details/53107018
去重考虑两点：去重的数据量，去重速度，为保证较快的去重速度，选择在内存中进行去重。

数据量不大时，可以直接放在内存里面进行去重，例如python使用set()进行去重。
当去重数据需要持久化时可以使用redis的set数据结构
当数据再大一点时，可以用不同的加密算法现将长字符串压缩成16/32/40个字符，在使用上面两种方法去重
当数据量达到亿级数量时，内存有限，必须使用'位'去重。

有几个seeds，现在申请一段内存空间，一个seed可以和字符串哈希映射到这段内存上的一个位，几个位都为1即表示该字符串已经存在。
m：表示内存大小(多少个位)
n：表示去重对象的数量
k：表示seed的个数

例如：代码中申请了256M，即1<<31(m=2^31,约21.5亿)，seed设置了7个。
看k=7那一列，当漏失率为8.56e-05时，m/n值为23.所以n=21.5/23=0.93(亿)，表示漏失率为8.56e-05时，256内存可能满足0.93亿条字符串的去重。
当漏失率为0.000112时，256M内存可满足0.98亿条字符串的去重

基于Redis的Bloom Filter去重，就是利用redis的string数据结构，但redis一个string最大只能512M，所以，如果去重的数据量大，需申请多个去重块(blockNum)
--------------------------------------------------------------------------------
Bloom-Filter(BF)算法(布隆过滤器)是一个很长的二进制向量和一系列随机映射函数

原理：利用多个哈希函数对相应源数据进行空间映射压缩，并利用位数组简洁的存储与表示一个集合。
在查询过程中，仅通过一次Hash映射过程即可判断一个元素是否属于这个集合，具有较少的空间占有率和较高的数据查询效率

用于检索一个元素是否在一个集合中

Bloom Filter是一种空间效率很高的随机数据结构，它利用位数组很简洁的表示一个集合，
并能判断一个元素是否属于这个集合。它是一个判断元素是否存在集合的快速的概率算法。

Bloom Filter有可能出现错误判断，但不会漏掉判断。
Bloom Filter判断元素不在集合，那就肯定不在，如果判断元素存在集合中，有一定概率判断错误
Bloom Filter不适合"零错误"的应用场合

优点：空间效率和查询时间都远远超过一般的算法
缺点：有一定的误识别率和删除困难

Bloom Filter算法的核心：利用不同Hash函数来解决"冲突"
Bloom Filter基本思想：
用Hash table的数据结构，运用一个足够好的Hash函数将一个URL映射到二进制位数组中的某一位，如果该位已经被置位1，那么表示该URL已经存在

Hash存在一个冲突（碰撞）的问题，用同一个Hash得到的两个URL的值可能相同。
为了减少冲突，可以引入多个Hash，如果通过其中的一个Hash值得出某元素不在集合中，那么该元素肯定不在集合中，
只有在所有Hash函数告诉我们该元素在集合中时，才能确定该元素存在于集合中。

原理要点：1.位数组 2.k个独立hash函数
关键：1.hash算法的设定 2.bit数组的大小确定
Bloom Filter参数：
    m    bit数组的宽度(bit数)
    n    加入其中的key的数量
    k    使用的hash函数的个数
    F    False Positive的比率



Scrapy借助Bloom Filter实现增量增量抓取
增量抓取的思路：保存上一次状态，本次抓取时与上一次比对，如果不在上次的状态中，便视为增量，保存下来。
上一次的状态是抓取的特征数据和上次抓取的request队列，request队列可以通过scrapy.core.scheduler的pending_requests成员得到，
在爬虫启动时导入上次爬取得特征数据，并且用上次request队列的数据作为start url进行爬取，不在上一次状态中的数据便保存。
